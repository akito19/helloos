# Day 4

### 1. C言語からメモリに書き込む
C言語とアセンブリを連携する場合は，自由に使っていいレジスタが決まっていて `EAX`, `ECX`, `EDX` に限られる．

これ以外のレジスタは値の利用にのみ利用して，値の変更はできない．

### 2. しましま模様

```c
for (i = 0xa0000; i <= 0xaffff; i++) {
    _write_mem8(i, i & 0x0f);
}
```

i の値にAND演算したものを `AL` レジスタに書き込む．`0x0f` は2進表記すると `00001111` なので，これにANDすると下位4ビットのみ値が残り，上位4ビットはすべて0が返る．つまり

```
00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F 01 02 03 ...
```

となり，16画素ごとに色番号を繰り返す．しましま〜

### 3-5: ポインタ

メモリアドレスを直接指定して値を記憶させる．

```
MOV [0x1234],0x56
```

というアセンブラの場合，指定するメモリが `BYTE`, `WORD`, `DWORD` なのか自明でないので，エラーになる（エラーにならないのはもう片方がレジスタのとき）．
そのため，

```c
for (i = 0xa0000; i <= 0xaffff; i++) {
    _write_mem8(i, i & 0x0f);
}
```

の代替として

```c
for (i = 0xa0000; i <= 0xaffff; i++) {
    *i = i & 0x0f
}
```

とかやろうとしても，コンパイル時に

```
MOV [i],(i & 0x0f)
```

を表現しようとして，メモリ指定時の型が `BYTE`, `WORD`, `DWORD` の判断がつかなくなって，エラーが出る．
このそれぞれについて，適切な型をコンパイラに知らせたい場合は，それぞれ以下の宣言を行う．

```c
char *p;  /* BYTE 用番地，符号付き8bit整数 */
short *p; /* WORD 用番地，符号付き16bit整数 */
int *p;   /* DWORD 用番地，符号付き32bit整数*/
```

なお

```c
char *p;

for (i = 0xa0000; i <= 0xaffff; i++) {
    p = i;
    *p = i & 0x0f;
}
```

みたいなことをやると，コンパイラに

```
warning: assignment makes pointer from integer without a cast [-Wint-conversion]
```

と怒られる．これは，メモリ番地を表すポインタに対して普通の数値（今回の場合は`int`型）を代入しているから．
この警告を回避するには，明示的にキャストするコードを入れる．
また，`p`への代入について

```c
p = i;         /* MOV ECX,i みたいな子  */
*p = i & 0x0f; /* MOV BYTE [ECX],(i & 0x0f) みたいな子 */
```

なので，`*` の有無で，それがレジスタに代入する計算なのか，メモリアドレスに代入する計算なのか異なる．
このケースにおいて`*p` は，`BYTE [p]` というメモリ番地を表すC言語上での表現でしかない．

また，

```c
char *p;

for (i = 0xa0000; i <= 0xaffff; i++) {
    p = i;
    *p = i & 0x0f;
}
```

は以下のようにも書ける．

```
p = (char *) 0xa0000
for (i = 0, i <= 0xffff; i++) {
    *(p + i) = i & 0x0f;
}
```

```c
p = (char *) 0xa0000
for (i = 0, i <= 0xffff; i++) {
    /* 配列っぽく見せるが，`*(p + i)` を表すだけ
       なお， `p[0]` と書けば，`*p` と同じ意味． */
    p[i] = i & 0x0f;
}
```

### 6. 色番号設定

C言語では

```c
char a[3];
```

としたとき，`a` は定数であり，アセンブラでいうところのラベルに相当するので，この場合は

```
a:
  RESB 3
```

に等しい．つまり，コード中の宣言

```c
static unsigned char table_rgb[16 * 3] = { ... }
```

は

```
table_rgb:
  DB 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, ...
```

を表す．代入する値が48個あり，`RESB` 命令でメモリアドレス1つ1つを計算したくないので，`RESB` 命令を `DB` 命令に置き換えるために `static` を付与する．48 byteで済む．

#### CLI, STI

割り込み許可を制御する．

* CLI
  * clear interrupt flag
  * 割り込み許可フラグを0にする，つまり割り込みを禁止する
* STI
  * set interrupt flag
  * 割り込み許可フラグを1にするる，つまり割り込み要求をCPUが受けたときに割り込みを行う

割り込み処理の詳細はきっと今後あると思う．

#### EFLAGS

16bitのレジスタが拡張された32bitレジスタで，キャリーフラグや割り込みフラグが詰まったレジスタ．
キャリーフラグの場合は，`JC` や `JNC` のようなジャンプ命令で判定できうるが，割り込みフラグにはそれを行える命令がないので，調べようとすると `EFLAGS` を読み込んでチェックするしかない．

`EFLAGS` を読み書きするための命令は `PUSHFD`, `POPFD` の2つ

* PUSHFD
  * push flags double-word
* POPFD
  * pop flags double-word
