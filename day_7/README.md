# Day 7

### キーコードを取得する

前回までのコードだと， キーが押されてもHLT命令を実行するので，一度押したらそこで処理が停止する．
そのため，適切に割り込みを行い，HLTさせずに何度も入力できるようにする．

キーボードの割り込み要求を受ける IRQ1 を発生させたら，それをOCW2に通知する．

### 手早い割り込み処理

harib04a では割り込み処理の関数内で文字表示を行っている．しかし割り込み処理中はその他のデバイスからの入力を受け付けないので，場合によっては処理がもたついて残念なことになる．
そのため，割り込み処理関数内で文字表示を行わず，割り込み時に受け取ったキーデータを変数に保存しておいて，その変数の確認と文字の表示を `HariMain` 関数の責務とする．

入力待ちをするとき，単に HLT してしまうと，いかなる入力も感知できないので， STI(set interrupt flag) 命令も同時に実行し，割り込みを受け付けられるようにしておく．
これにより，PICから命令を受ければCPUがまた動き出す．

### FIFOバッファをつくる

特に新しいことはない．
harib04bまでのコードだと，1バイトしかデータを保存できなかったため，表示しきれないキーコード*(Right Ctrl)があった．
それを是正するために以下のような構造体を作った．

```c
struct KEYBUF {
    unsigned char data[32]
    int next;
};
```

キーが入力されたときに data として push し，表示時にそれを `next` により順繰り取り出す．ただし，この場合，data が十分に大きいとき，最大32個のデータをずらして取得することになる．

### FIFOバッファを改良する

ここまでの問題を解決するために，読み出すときのみ順繰り処理を行うだけでなく，書き込むときも `next` する．
ただし，単に `next` するだけでは `data[31]`（つまり配列(?)の最後）に到達したときに書き込みができなくなるので，それを避けるために，配列を環状に利用する．つまり配列の最後まで到達したら先頭の `data[0]` に戻って書き込みを行うようにする．

### FIFOバッファを整理する

harib04d までは最大32byteまでしか利用できなかったので，その制限をなくした．

### マウス

マウスの割り込み番号はIRQ12（キーボードは IRQ1）であり，数字が大きい．これは，マウスが比較的新しい入力デバイスだから．

マウスが登場したとき，ほとんどのOSはまだマウスに対応していなかったので，有効化命令を実行しないと割り込み信号を出さない設計になっていた．
つまり，マウスを操作できるようにするためには，マウス制御回路及びマウスに有効化の命令を発行する必要がある．

ただし，マウス制御回路はキーボード制御回路の中にあるので，キーボード制御回路をうまく初期化することでマウス制御回路を有効にできる．
