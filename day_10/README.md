# Day 10

#### はりぼてOSのメモリマップ

```
0x00000000 - 0x000fffff : 起動中に色々使うが，その後は空き(1MB)
0x00100000 - 0x00267fff : フロッピーディスクの内容記憶用(1440KB)
0x00268000 - 0x0026f7ff : あき(30KB)
0x0026f800 - 0x0026ffff : IDT(2KB)
0x00270000 - 0x0027ffff : GDT(64KB)
0x00280000 - 0x002fffff : bootpack.hrb(512KB)
0x00300000 - 0x003fffff : スタックなど(1MB)
0x00400000 -            : あき
```

### 桁の切り下げ

プログラム中で値を切り下げることを考える．
たとえば `0x12345678` を `0x1000` 単位で切り捨てるのならば `0x12345000` となる．
このように，ある数を切り捨てて新しい値をつくるときはAND演算を用いる．

```
0x12345678 & 0xfffff000 = 0x12345000
```

16進数は結局4桁の2進数の集合なので，切り捨てたい桁をすべて `0` ，残す桁を `f` (= `1111`)として AND すればよい．

### 桁の切り上げ

`0x12345678` を同様に `0x1000` で切り上げる場合，求める値は `0x12346000` である．
つまり，桁の切り下げを行ってから，切り上げたい桁を足せばよいが，その場合，元の数が `0x12345000` のとき `0x12346000` となるので，都合がよくない．
これを避けるために，予め最初の下の桁を見て，0 でなければ切り上げをするという処理を加える：

```c
if ((i & 0xfff) != 0) {
  i = (i & 0xfffff000) + 0x1000;
}
```

また，元の値にまず基準となる桁より1少ない値（`0x1000` なら `0xfff`）を先に足してから桁の切り下げを行うことでも表現できる．

```
i = (i + 0xfff) & 0xfffff000;
```
