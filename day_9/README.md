# Day 9

#### はりぼてOSのメモリマップ

```
0x00000000 - 0x000fffff : 起動中に色々使うが，その後は空き(1MB)
0x00100000 - 0x00267fff : フロッピーディスクの内容記憶用(1440KB)
0x00268000 - 0x0026f7ff : あき(30KB)
0x0026f800 - 0x0026ffff : IDT(2KB)
0x00270000 - 0x0027ffff : GDT(64KB)
0x00280000 - 0x002fffff : bootpack.hrb(512KB)
0x00300000 - 0x003fffff : スタックなど(1MB)
0x00400000 -            : あき
```

### Cache Memory

計算機上で実行される命令のほとんどはループ処理であり，それを実行する間は，メモリの同じアドレスを何度も見ることになる．
メモリはCPUから物理的に遠い位置にあり，何度も見に行くことが大きなオーバーヘッドになるので，CPU内にキャッシュ用のメモリをおいて，まずキャッシュメモリを見に行くような構成になる．

書き込みの場合も同様に，まずキャッシュ内の情報を更新した上で，最後にメモリへの書き込みを行う．

また，キャッシュの有効無効を操作するためには `CR0` レジスタの中にあるフラグを操作する．

### メモリ管理
たぶん1例だと思う．
`bootpack.c` のコード見たほうが早い．

#### メモリ確保

ある単位でアドレス空間を分けて，分けた単位のサイズと確保したいサイズを比べる．
十分な広さを見つけたときは，そのアドレスを返り値として渡し，アドレスのブロックを1つ後ろにずらし，空きメモリ容量も1サイズ分小さくする．

#### メモリ解放

開放時はその時点で開放対象（直前のプロセスで使っていた）アドレス空間の前後をみて，まず前方に空きがあるか，後方に空きがあるか，それとも空きがないかを確認する．
次に開放したいプロセスのメモリアドレスを開放する．このとき，解放後のアドレスの前後とマージ可能ならばマージしてしまう．

これにより，メモリ確保時に，マージしていたら必要分のメモリサイズなのに，分割されているがゆえに必要なメモリ分が空いていないという判断をされて，そのメモリが宙ぶらりんになるのを防ぐ．
e.g. あるプロセスの実行に 100KB のメモリがほしいが，ある連続したメモリ空間上で，allocatableなメモリサイズが 90KB と 30KB に分かれているみたいな場合．
